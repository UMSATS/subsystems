#   UMSATS GUI
#
#   File Description:
#       This file was generated by PAGE. Functions were added which define the functionality of the GUI.
#
#   History
#   2018-05 by Huy Bui.
#       -   Created using PAGE.
#
#   2018-06 by Joseph Howarth.
#       - Created callback functions.
#
#   2018-12-09 by Joseph Howarth
#       -   Organized and refactored to follow programming standards.
#
# Support module generated by PAGE version 4.13
# In conjunction with Tcl version 8.6
#    May 31, 2018 11:43:13 PM


import serialFunctions as serialF
import datetime
import threading
import queue

POWER_ID          = 0x100
GROUND_STATION_ID = 0x200
CDH_ID            = 0x300
DIAGNOSTIC_ID     = 0x400
PAYLOAD_ID        = 0x500
SERIAL_ID         = 0x600

ACCEPTED_IDS = [POWER_ID,GROUND_STATION_ID,CDH_ID,DIAGNOSTIC_ID,PAYLOAD_ID]

COMMS_START = 0
COMMS_STOP  = 1

LOGGING = True
commandList = {'POWER': 1, 'PAYLOAD': 2, 'GROUND': 3, 'COMMS': 4, 'ON': 99, 'OFF': 100}

baudrateList = [9600, 115200]
canReceive = ""

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False

except ImportError:
    import tkinter.ttk as ttk
    py3 = True


def set_Tk_var():
    # Set up variables to hold any inputs from the gui.

    global Com1Input, Com2Input, Baud1Input, Baud2Input
    Com1Input = StringVar()
    Com2Input = StringVar()
    Baud1Input = StringVar()
    Baud2Input = StringVar()

    global powerInput, payloadWellInput, payloadValueInput, groundWellInput, groundValueInput, ADC_Num

    powerInput = StringVar()
    payloadWellInput = StringVar()
    payloadValueInput = StringVar()
    groundWellInput = StringVar()
    groundValueInput = StringVar()
    ADC_Num = StringVar()

    global che47
    che47 = StringVar()
    global che48
    che48 = StringVar()

    global cmd1Text, cmd2Text

    cmd1Text = StringVar()
    cmd2Text = StringVar()


def init(top, gui, *args, **kwargs):
    global w, top_level, root, running
    global serial1, serial2, baud1, baud2, com1, com2, logFile1, logFile2, date
    global closeEvent, threadQueue1, threadQueue2, thread1, thread2

    running = True

    w = gui
    top_level = top
    root = top

    baud1 = 115200
    baud2 = 9600

    com1 = ""
    com2 = ""

    logFile1 = None
    logFile2 = None

    serial1 = None
    serial2 = None

    top_level.bind_all('<<newSerialData>>', update_display)  # When a <<newSerialData>> event is received, update the display.

    closeEvent = threading.Event()  # This event signals to stop the read function when the program is closed.

    threadQueue1 = queue.Queue()  # This queue is used to transfer data from the read thread to the gui to be displayed.
    thread1 = None

    threadQueue2 = queue.Queue()  # This queue is used to transfer data from the read thread to the gui to be displayed.
    thread2 = None


def clear_display(display1, display2):

    print("clearing display")
    display1.delete("0", END)
    display2.delete("0", END)


def update_display(event):
    """ This function prints any new serial data to the display.
    """

    # event.widget is topLevel.
    display1 = event.widget.children['!labelframe'].children['!listbox']
    display2 = event.widget.children['!labelframe'].children['!listbox2']

    # print("updating display")

    global canReceive

    if not threadQueue1.empty():

        data1 = threadQueue1.get_nowait()  # Get any data from the queue.
        if LOGGING:
            logFile1.write(data1)  # Save it to log file.

        data = data1.split(" ")

        # If the length of data is less than 1, then it is invalid.
        if len(data) > 1:
            can_id = data[1]
        else:
            can_id = ""

        # For now ignore any message with ID except Serial_ID.
        if can_id in ACCEPTED_IDS:
            pass

        if can_id == SERIAL_ID:
            length = int(data[3])
            # print("ID: "+ id+ " len: "+ str(length))
            for index in range(5, length+5):

                character_hex = data[index].replace("0x", "")
                ascii_char = chr(int(character_hex, 16))

                if ascii_char != "\0":
                    canReceive += ascii_char

                if ascii_char == "\n":

                    display2.insert(END, canReceive[:-1])
                    display2.see(display2.size())
                    canReceive = ""

                display2.see(display2.size())
        else:
            # If the message wasn't a CAN message, then it was from the Arduino, so show it in top window.
            display1.insert(END, data1)
            display1.see(display1.size())  # This scrolls the window so the new text is always visible.

    if not threadQueue2.empty():
        # Print any messages from second serial port.
        data2 = threadQueue2.get_nowait()  # Get any data from the queue.
        if LOGGING:
            logFile2.write(data2)  # save it to log file;
        display2.insert(END, data2)
        display2.see(display2.size())  # This scrolls the window so the new text is always visible.


def destroy_window():

    # Function which closes the window.
    global top_level, closeEvent
    print("closing ")
    closeEvent.set()  # Set this event so that the receive threads stop themselves.

    if logFile1 is not None:
        logFile1.close()
    if logFile2 is not None:
        logFile2.close()

    if serial1 is not None:
        serial1.close()

    if serial2 is not None:
        serial2.close()

    top_level.destroy()
    top_level = None


def write_command(display, can, data):
    """
       The function takes the text in the input box and sends it over the can bus.
       The text is also written to the display box.
       can should be either 1 or 2.

       Parameters
       display:     Reference to the widget where the command will be shown.
       can:         An integer, either 1 or 2, which is the CAN bus that the command will be sent on.
       data:        A string which is the command to be sent.
    """

    # Store the text in the cmdLine

    data = data.strip('\n')

    command = None

    check_command = data.split(' ')

    if check_command[0] in commandList.keys():
        command = check_command[0]

    value = check_command[1:]

    # Get a reference to the display associated with the terminal and write to correct serial port.
    if (can == 1) and (serial1 is not None):

        if command is None:

            serial1.write(data)
            if LOGGING:
                logFile1.write("-> " + data)

        else:

            full = ""
            extra = ""  # ?

            full += str(commandList[command]) + extra + " "

            for v in value:

                full += (str(v)) + " "

            serial1.write(full)
            if LOGGING:
                logFile1.write("-> " + full + "\n")

    elif (can == 2) and (serial2 is not None):

        if command is None:

            serial2.write(data)
        if LOGGING:
            logFile2.write("-> " + data)
        else:

            full = ""

            full += str(commandList[command]) + " "
            for v in value:

                full += (str(v)) + " "
            serial2.write(full)
            if LOGGING:
                logFile2.write("-> " + full + "\n")


    # Show command in display.
    display.insert(END, "-> "+data + '\n')
    display.see(display.size())


def read(closed_event, rx_queue, serial_port):
    """ This function reads data from the serial port.
        When ever there is actual data, a <<newSerialEvent>> is generated.
        When a <<closedEvent>> is received the function is stopped.

    """

    if running:
        while True:

            if closed_event.is_set():
                break

            data = serial_port.read()

            # If there is data to read put in queue and generate event to update display.
            if not (data is None) and (data != "") and (data != '\0'):

                rx_queue.put(data)

                try:

                    root.event_generate('<<newSerialData>>', when='tail')

                except:

                    print("newSerialData event generated FAILED")

                    break


def update_com_list(e):
    '''
        Updates the list of COM Ports available.
    '''

    com_port_list = serialF.SerialFunctions.list_COM_ports()

    try:
        com_port_list.remove(Com1Input.get())
    except:
        pass
    try:
        com_port_list.remove(Com2Input.get())
    except:
        pass
    e.configure(values=com_port_list)


def setup_serial(e, port, baudrate, can):
    '''
    Parameters
    port:       A string of the form 'COMxx', where xx is the port number.
    baudrate:   An integer.
    can:        An integer, either 1 or 2, which selects which CAN bus/serial port is being setup.
    '''

    print("Starting serial communication on CAN bus {}.\nCOM port: {}\nBaudrate: {}".format(can, port, baudrate))


    date_obj = datetime.datetime.now()
    date = date_obj.strftime('%Y-%m-%d %Hh%Mm%Ss')

    global serial1, serial2, logFile1, logFile2, thread1, thread2
    if port == "":
        print("no com port selected")
        return

    if can == 1:

        # If the Can bus already has a serial port, close it.
        if serial1 is not None:
            print("closed serial port")
            serial1.close()

        if LOGGING:
            logFile1 = open("CAN1Log_" + date + ".txt", 'w')

        serial1 = serialF.SerialFunctions(baudrate, port)
        thread1 = threading.Thread(target=read, args=(closeEvent, threadQueue1, serial1))
        thread1.start()

    else:

        if serial2 is not None:
            serial2.close()

        if LOGGING:
            logFile2 = open("CAN2Log_" + date + ".txt", 'w')

        serial2 = serialF.SerialFunctions(int(baudrate), port)
        thread2 = threading.Thread(target=read, args=(closeEvent, threadQueue2, serial2))
        thread2.start()


def sendPower(e, frame):

    write_command(frame.children['!listbox'], 1, "POWER " + powerInput.get())
    powerInput.set("")


def sendPayload(e, frame):

    write_command(frame.children['!listbox'], 1, "PAYLOAD " + payloadWellInput.get() + " " + payloadValueInput.get())
    payloadWellInput.set("")
    payloadValueInput.set("")


def sendComms(e, frame, cmd):

    write_command(frame.children['!listbox'], 1, "COMMS " + str(cmd) + " " + payloadValueInput.get())


def sendGroundOn(e, frame):

    write_command(frame.children['!listbox'], 1, "GROUND " + "1 " + groundWellInput.get() + " " + groundValueInput.get())
    groundWellInput.set("")
    groundValueInput.set("")


def sendGroundOff(e, frame):

    write_command(frame.children['!listbox'], 1, "GROUND " + "2 " + groundWellInput.get() + " " + groundValueInput.get())
    groundWellInput.set("")
    groundValueInput.set("")


def sendDumpPayload(e, frame):

    write_command(frame.children['!listbox'], 1, "GROUND " + "3 " + "0" + " " + groundValueInput.get())
    groundWellInput.set("")
    groundValueInput.set("")


def sendADC(e, frame):

    write_command(frame.children['!listbox'], 1, "GROUND " + "4 " + ADC_Num.get() + " " + groundValueInput.get())
    groundWellInput.set("")
    groundValueInput.set("")


def showWells(combo):

    wells = [x for x in range(1, 6)]
    combo.configure(values=wells)


def showADCs(combo):

    adcs = [c for c in range(1, 5)]
    combo.configure(values=adcs)


if __name__ == '__main__':
    import UMSATSGUI
    UMSATSGUI.vp_start_gui()


